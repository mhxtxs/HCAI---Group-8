<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>KNN Flower Classifier ‚Äì Explainable Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

  <!-- Inline styles for the heatmap card -->
  <style>
    body {
      background-image: url("{{ url_for('static', filename='images/bg_img.jpg') }}");
      background-size: cover !important;
      background-repeat: no-repeat;
      background-attachment: fixed;
    }
    .heatmap-pair {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      margin-top: 12px;
    }
    .heatmap-col {
      flex: 1 1 220px;
    }
    .heatmap-col h4 {
      margin-bottom: 6px;
      font-size: 0.9rem;
      opacity: 0.9;
    }
    .heatmap-img {
      width: 100%;
      max-width: 260px;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      object-fit: cover;
      display: block;
    }
    .similarity-label {
      margin-top: 6px;
      font-weight: 600;
      color: #0ea5e9;
      font-size: 0.95rem;
    }
  </style>
</head>
<body>
  <main class="app-root">

    <!-- ================= HEADER ================= -->
    <header class="hero">
      <div class="hero-text">
        <h1 class="hero-title">FlowerLens</h1>
        <p class="hero-subtitle">
          FlowerLens is built on the K-Nearest Neighbours (KNN) algorithm. With our tool you can
          transparently see how the algorithm works. Take a picture of a flower,
          upload it, and FlowerLens will show you which flowers in the training data are most similar.
        </p>

        <ul class="hero-list">
          <li>Upload your own flower image and receive the name of the flower.</li>
          <li>Inspect the training dataset, add or remove images, and click individual data points.</li>
          <li>Adjust KNN parameters and see how they influence the result.</li>
        </ul>
      </div>

      <div class="hero-image">
        <div class="hero-image-main">
          <img src="{{ url_for('static', filename='flower_tool.png') }}">
        </div>
      </div>
    </header>

    <!-- ================= STEP-GUIDE ================= -->
     <section class="how-card" id="how-it-works">
       <div class="how-card-header">
        <h2>How FlowerLens works</h2>
        <p>
          Click a step to see what happens inside the KNN model and jump to the
          relevant part of the interface.
        </p>
      </div>
      <div class="how-card-body">
        <div class="how-steps-list" role="tablist" aria-label="How FlowerLens works steps">
          <button class="how-step active" type="button" data-step="1">
            <span class="how-step-number">1</span>
            <span class="how-step-label">Model memory</span>
          </button>
          <button class="how-step" type="button" data-step="2">
            <span class="how-step-number">2</span>
            <span class="how-step-label">Your flower</span>
          </button>
          <button class="how-step" type="button" data-step="3">
            <span class="how-step-number">3</span>
            <span class="how-step-label">Feature space</span>
          </button>
          <button class="how-step" type="button" data-step="4">
            <span class="how-step-number">4</span>
            <span class="how-step-label">Measure distances</span>
          </button>
          <button class="how-step" type="button" data-step="5">
            <span class="how-step-number">5</span>
            <span class="how-step-label">Nearest neighbours</span>
          </button>
          <button class="how-step" type="button" data-step="6">
            <span class="how-step-number">6</span>
            <span class="how-step-label">Neighbour vote</span>
          </button>
          <button class="how-step" type="button" data-step="7">
            <span class="how-step-number">7</span>
            <span class="how-step-label">Explanation</span>
          </button>
        </div>
        <div class="how-step-detail" aria-live="polite">
          <h3 id="how-step-title"> ¬∑ Model memory</h3>
          <p id="how-step-text">
            FlowerLens starts with a small training dataset of labelled flower images.
            This is the model‚Äôs memory. You can explore it in the
            <a href="#view-dataset">training data &amp; explanation view</a>.
          </p>
        </div>
      </div>
    </section>


    <!-- ================= VIEW TOGGLE ================= -->
     <nav class="view-toggle" id="page-nav">
      <button class="view-tab active" type="button" data-scroll="view-assistant"> ¬∑ Ask FlowerLens</button>
      <button class="view-tab" type="button" data-scroll="view-dataset"> ¬∑ Training data & feature space</button>
      <button class="view-tab" type="button" data-scroll="distance-explanation"> ¬∑ Distances & neighbour vote</button>
      <a class="view-tab" href="{{ url_for('model_card') }}"> ¬∑ Model card</a>
    </nav>


    <!-- ====================================================================== -->
    <!--                                VIEW: CHAT                             -->
    <!-- ====================================================================== -->
    <section id="view-assistant" class="app-view active">
      <section class="main-area">

        <!-- ========= CHAT PANEL ========= -->
        <section class="chat-panel">
          <div class="chat-header">
            <h2>Ask FlowerLens</h2>
          </div>

          <!-- Small settings summary -->
          <div class="settings-summary" id="settings-summary">
            <span class="summary-label">Current KNN settings</span>
            <span class="summary-value" id="summary-k">k = 5</span>
            <span class="summary-dot">¬∑</span>
            <span class="summary-value" id="summary-metric">Metric: Euclidean</span>
          </div>

          <div class="chat-window" id="chat-window">
            <div class="chat-message bot">
              <div class="chat-bubble">
                Hi! Upload a flower image and I'll tell you what species it may be.
              </div>
            </div>
          </div>

          <div class="chat-input-row">
            <button id="chat-upload-btn" class="btn-upload highlighted-upload">
              <span class="upload-icon">üì∑</span>
              <span class="upload-label">Upload flower image</span>
            </button>
            <input type="text" id="chat-input" class="chat-input" placeholder="Ask me something‚Ä¶" />
            <button id="chat-send" class="btn-primary">Send</button>

            <input type="file" id="file-input" accept="image/*" hidden />
          </div>

          <!-- Preview UNDER upload button -->
          <div id="pending-preview" style="margin-top: 10px; text-align:center;"></div>

          <p class="chat-hint">
            First upload a flower image, then you can ask questions about the prediction.
          </p>
        </section>

        <!-- ========= RIGHT SIDE: SETTINGS ======== -->
        <aside class="side-panel">
          <section class="side-card">
            <h2 class="side-title">Settings for the KNN Algorithm</h2>

            <!-- K -->
            <div class="param-group">
              <label for="k-slider">
                Number of neighbours <span class="badge" id="k-value">5</span>
              </label>
              <input id="k-slider" type="range" min="1" max="25" step="1" value="5" />
              <p class="param-help">
                <strong>k</strong> controls how many neighbours vote.  
                Small k ‚Üí sensitive to noise.  
                Large k ‚Üí smoother but less detailed.
              </p>
            </div>

            <!-- Distance metric -->
            <div class="param-group">
              <label for="metric-select">Distance metric</label>
              <select id="metric-select">
                <option value="euclidean">Euclidean distance</option>
                <option value="manhattan">Manhattan distance</option>
                <option value="minkowski">Minkowski distance (p-th order)</option>
              </select>
              <p id="metric-description" class="param-help">
                Euclidean distance measures straight-line distance like with a ruler.
              </p>
            </div>
            <p class="param-note">
              The chat also uses these exact settings when making predictions.
            </p>
            
            <div class="compare-actions">
              <button class="btn-secondary" id="btn-open-compare" type="button">
                Open comparison view
              </button>
              <p class="param-help compare-help">
                Compare two different <strong>k</strong> and distance-metric choices side-by-side.
              </p>
            </div>
          </section>
        </aside>

      </section>
    </section>

    <!-- =========================================================================== -->
    <!--                         VIEW: DATASET + EXPLAINABILITY                      -->
    <!-- =========================================================================== -->
    <section id="view-dataset" class="app-view active">


      <section class="dataset-intro-card">
        <h2>Training data used by the KNN model</h2>

        <div class="settings-summary settings-summary-compact">
          <span class="summary-label">Current KNN settings</span>
          <span class="summary-value" id="summary-k-2">k = 5</span>
          <span class="summary-dot">¬∑</span>
          <span class="summary-value" id="summary-metric-2">Metric: Euclidean</span>
        </div>

        <p>
          These are the flowers the model compares your uploaded image to.
        </p>

        <ul>
          <li>Click a point or row to inspect it.</li>
          <li>Add or remove images to understand how the model adapts.</li>
          <li>Changing k or the distance metric changes the nearest neighbours.</li>
        </ul>

        <p class="param-note">
          Think of this as the model‚Äôs <strong>memory</strong>.
        </p>
      </section>

      <!-- ========================= DATASET & PLOT ========================== -->
      <section class="dataset-area">

        <!-- PLOT -->
        <article class="plot-card" id="feature-space">
          <h2>Dataset in feature space</h2>
          <p class="plot-caption">
            Each dot is a flower from the training dataset.  
            The uploaded flower appears as a turquoise star.
          </p>

          <div id="dataset-scatter" class="plot"></div>
          <p class="plot-legend-note">
             <strong>Legend:</strong><br>
             Coloured dots = flowers from the training data set<br>
             Turquoise star = uploaded flower<br>
             Gold ring = current k nearest neighbours
</p>
        </article>

        <!-- DATASET EXPLORER -->
        <article class="plot-card">
          <h2>Dataset explorer</h2>

          <p class="plot-caption">
            Add, remove or inspect flowers in the training dataset.
          </p>

          <div class="dataset-controls">
            <div class="filter-group">
              <label for="class-filter">Filter by class:</label>
              <select id="class-filter">
                <option value="all">All classes</option>
                <option value="setosa">Setosa</option>
                <option value="versicolor">Versicolor</option>
                <option value="virginica">Virginica</option>
              </select>
            </div>

            <div class="dataset-buttons">
              <button class="btn-secondary" id="btn-add-image">Add new image</button>
              <button class="btn-secondary" id="btn-remove-image" disabled>Remove selected image</button>
            </div>
          </div>

          <input type="file" id="dataset-file-input" accept="image/*" hidden />

          <div class="table-wrap">
            <table class="data-table" id="dataset-table">
              <thead>
                <tr>
                  <th>Image</th>
                  <th>Id</th>
                  <th>Class</th>
                  <th>Source</th>
                  <th>In training</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>

          <p class="note">
            Clicking a row or dot shows details here:
          </p>

          <div id="point-details" class="point-details">
            <p>No point selected yet. Click a dot or row.</p>
          </div>
        </article>
      </section>

      <!-- ===================== HEATMAP EXPLAINER CARD ====================== -->
      <section class="plot-card" id="heatmap-explainer-card">
        <h2>Heatmap visual explanation</h2>
        <p class="plot-caption">
          Left: your uploaded flower. Right: a gradient-based heatmap showing visually important regions.
        </p>
        <div class="heatmap-pair">
          <div class="heatmap-col">
            <h4>Original image</h4>
            <img id="explainOriginalImage" class="heatmap-img" src="" alt="Original flower">
          </div>
          <div class="heatmap-col">
            <h4>Heatmap</h4>
            <img id="explainHeatmapImage" class="heatmap-img" src="" alt="Heatmap overlay">
            <p id="similarityText" class="similarity-label"></p>
          </div>
        </div>
      </section>

      <!-- (Explainability long text sections ‚Äì unchanged, omitted here for brevity if you want,
           but you can keep all your existing neighbour influence / distance explanations) -->

      <!-- =========================== EXPLAINABILITY =============================== -->
      <section class="distance-card" id="distance-explanation">
        <h2>Distance measures, neighbour selection & class vote</h2>
        <p>
          The model measures how far each training flower is from the uploaded one.
          Different distance metrics define ‚Äúcloseness‚Äù differently.
        </p>

        <div class="stepper distance-stepper">
          <button class="step-pill distance-tab active" data-metric="euclidean">Euclidean</button>
          <button class="step-pill distance-tab" data-metric="manhattan">Manhattan</button>
          <button class="step-pill distance-tab" data-metric="minkowski">Minkowski</button>
        </div>

        <div class="distance-panel exp-panel active" data-metric-panel="euclidean">
          <h3>Euclidean distance (straight line)</h3>
          <p>The standard ruler distance:</p>
          <div class="formula-box">
            d = ‚àö[(x ‚àí x‚òÖ)¬≤ + (y ‚àí y‚òÖ)¬≤]
          </div>
          <p>Highlighted rows below represent the current k nearest neighbours.</p>
        </div>

        <div class="distance-panel exp-panel" data-metric-panel="manhattan">
          <h3>Manhattan distance (grid)</h3>
          <p>Moves only horizontally/vertically:</p>
          <div class="formula-box">
            d = |x ‚àí x‚òÖ| + |y ‚àí y‚òÖ|
          </div>
          <p>Rows highlighted in gold are the nearest neighbours.</p>
        </div>

        <div class="distance-panel exp-panel" data-metric-panel="minkowski">
          <h3>Minkowski distance (p-th order)</h3>
          <p>A general version of both Euclidean and Manhattan:</p>
          <div class="formula-box">
            d = ( |x‚àíx‚òÖ|<sup>p</sup> + |y‚àíy‚òÖ|<sup>p</sup> )<sup>1/p</sup>
          </div>

          <div class="minkowski-row">
            <label for="p-slider">Minkowski order p</label>
            <div class="p-slider-wrap">
              <input type="range" id="p-slider" min="1" max="5" step="0.1" value="2" />
              <span id="p-value">p = 2.0</span>
            </div>
            <p class="param-help">
              p = 1 ‚Üí Manhattan  
              p = 2 ‚Üí Euclidean  
              Values in between blend both effects.
            </p>
          </div>
        </div>

        <div class="distance-table-wrap">
          <table class="data-table distance-table" id="distance-table">
            <thead>
              <tr>
                <th>#</th>
                <th>Id</th>
                <th>Class</th>
                <th>x</th>
                <th>y</th>
                <th>Œîx</th>
                <th>Œîy</th>
                <th>d</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </section>

      <section class="majority-overview">
        <h3>Majority vote & final decision</h3>
        <p>
          Once distances are computed, the model selects the <strong>k</strong> nearest neighbours
          and counts the classes among them. The class with the highest count is the prediction.
        </p>

        <p class="vote-summary" id="vote-summary"></p>
      </section>

      <section class="vote-details">
        <div class="how-read-box">
          <h3>How to read the vote summary</h3>
          <p>
            Each flower in the training set ‚Äúvotes‚Äù for a class. The <strong>k nearest neighbours</strong> 
            are the only ones allowed to vote.
          </p>
          <ul class="read-list">
            <li>üåº <strong>Setosa</strong> ‚Üí votes from flowers with similar small petals.</li>
            <li>üåº<strong>Versicolor</strong> ‚Üí medium-sized flowers contribute here.</li>
            <li>üåº <strong>Virginica</strong> ‚Üí larger flowers influence this class.</li>
          </ul>
          <p>
            The species with the <strong>highest number of votes</strong> becomes the predicted flower.
            If the votes are close, confidence will be lower.
          </p>
          <p class="read-note">
            Confidence = (Votes for predicted class √∑ k) √ó 100  
          </p>
        </div>
      </section>
      <!-- ====================================================================== -->
<!--                     NEIGHBOUR INFLUENCE EXPLANATION                    -->
<!-- ====================================================================== -->
<section class="explainability-deep-card">
  <h2>Understanding Neighbour Influence in KNN</h2>

  <p>
    The K-Nearest Neighbours (KNN) algorithm compares the uploaded flower with
    every flower in the training dataset, selects the closest neighbours, and
    predicts the class that appears most frequently among them. However, not all 
    neighbours contribute equally. To make this transparent, FlowerLens introduces
    a <strong>Neighbour Influence Heatmap</strong> that reveals how much each 
    neighbour affects the prediction.
  </p>

  <h3>Why Influence Matters</h3>
  <p>
    Even within the top <em>k</em> neighbours, distance varies. A flower extremely 
    close to the uploaded image contributes more strongly than one barely in the 
    top <em>k</em>. The heatmap visualises this difference by assigning each 
    neighbour a weighted influence score.
  </p>

  <h3>How Influence is Calculated</h3>
  <p>For each neighbour in the top <em>k</em>:</p>

  <div class="formula-box">
    Influence = 1 / distance
  </div>

  <p>This ensures:</p>
  <ul>
    <li>Close neighbours have high influence</li>
    <li>Farther neighbours have lower influence</li>
    <li>Influence changes smoothly with distance</li>
  </ul>

  <p>The influence is then normalised:</p>
  <div class="formula-box">
    Normalised Influence = Influence / Max Influence
  </div>
</section>

<section class="explainability-deep-card2">
  <h3>Visual Encoding: Colour Heatmap Bars</h3>
  <p>Influence is mapped to colour-coded bars:</p>

  <ul>
    <li style="color:#22c55e;"><strong>Green</strong> ‚Üí High influence (closest neighbours)</li>
    <li style="color:#eab308;"><strong>Yellow</strong> ‚Üí Medium influence</li>
    <li style="color:#ef4444;"><strong>Red</strong> ‚Üí Low influence (far neighbours)</li>
  </ul>

  <p>
    Bars animate according to influence score, making KNN easy to understand even
    for non-technical users.
  </p>

  <h3>Educational Value</h3>
  <p>This module reveals:</p>
  <ul>
    <li>Which samples matter most</li>
    <li>How distance affects classification</li>
    <li>The effect of adjusting <em>k</em></li>
    <li>Differences between Euclidean, Manhattan, and Minkowski metrics</li>
    <li>Impact of noisy or mislabeled data</li>
  </ul>

  <h3>Conclusion</h3>
  <p>
    The Neighbour Influence Heatmap transforms KNN from ‚Äúupload ‚Üí predict‚Äù
    into a transparent, explainable learning tool.
  </p>
</section>

    </section> <!-- END VIEW DATASET -->

  </main>

  <!-- ===================== COMPARISON VIEW (MODAL) ===================== -->
<div id="comparison-modal" class="comparison-modal" aria-hidden="true">
  <div id="comparison-backdrop" class="comparison-backdrop"></div>

  <div class="comparison-dialog" role="dialog" aria-modal="true" aria-labelledby="comparison-title">
    <header class="comparison-header">
      <div>
        <h2 id="comparison-title">Compare KNN settings</h2>
        <p class="comparison-subtitle">
          Left: your <strong>current</strong> settings. Right: a <strong>comparison</strong> setting you can adjust.
        </p>
      </div>

      <button class="btn-secondary comparison-close" id="comparison-close" type="button" aria-label="Close comparison view">
        ‚úï
      </button>
    </header>

    <div class="comparison-grid">
      <!-- CURRENT -->
      <section class="comparison-panel">
        <div class="comparison-panel-head">
          <h3>Current</h3>
          <div class="comparison-badges">
            <span class="badge" id="compare-main-badge">k = 5 ¬∑ Euclidean</span>
            <span class="badge badge-soft" id="compare-main-p-badge" style="display:none;">p = 2.0</span>
          </div>
        </div>

        <div id="compare-plot-main" class="plot compare-plot"></div>
        <div class="compare-result" id="compare-main-result"></div>

      </section>

      <!-- COMPARISON -->
      <section class="comparison-panel">
        <div class="comparison-panel-head">
          <h3>Comparison</h3>
          <div class="comparison-badges">
            <span class="badge" id="compare-alt-badge">k = 5 ¬∑ Euclidean</span>
            <span class="badge badge-soft" id="compare-alt-p-badge" style="display:none;">p = 2.0</span>
          </div>
        </div>

        <div class="compare-controls">
          <div class="param-group">
            <label for="compare-k">
              Number of neighbours <span class="badge" id="compare-k-value">5</span>
            </label>
            <input id="compare-k" type="range" min="1" max="25" step="1" value="5" />
          </div>

          <div class="param-group">
            <label for="compare-metric">Distance metric</label>
            <select id="compare-metric">
              <option value="euclidean">Euclidean distance</option>
              <option value="manhattan">Manhattan distance</option>
              <option value="minkowski">Minkowski distance (p-th order)</option>
            </select>
            <p id="compare-metric-description" class="param-help">
              Euclidean distance measures straight-line distance like with a ruler.
            </p>
          </div>

          <div class="param-group" id="compare-p-wrap" style="display:none;">
            <label for="compare-p-slider">Minkowski order (p)</label>
            <div class="p-row">
              <input id="compare-p-slider" type="range" min="1" max="6" step="0.1" value="2" />
              <span id="compare-p-value">p = 2.0</span>
            </div>
            <p class="param-help">
              p = 1 ‚Üí Manhattan ¬∑ p = 2 ‚Üí Euclidean
            </p>
          </div>
        </div>

        <div id="compare-plot-alt" class="plot compare-plot"></div>
        <div class="compare-result" id="compare-alt-result"></div>
      </section>
    </div>

    <footer class="comparison-footer">
      <button class="btn-secondary" id="comparison-swap" type="button">Swap</button>
      <button class="btn-secondary" id="comparison-copy-current" type="button">Copy current ‚Üí comparison</button>
    </footer>
  </div>
</div>





  <!-- =========================================================================== -->
  <!--                               JAVASCRIPT LOGIC                              -->
  <!-- =========================================================================== -->
  <script>
    /* --------------------------------------------------------------
       DATASET
    -------------------------------------------------------------- */
    const datasetPoints = [
      { id: 1, label: 'iris setosa', x: 1.2, y: 0.8, source: 'Original dataset', inTraining: true, image: 'static/images/iris_setosa.jpg',
        features: { sepal_length: 5.1, sepal_width: 3.5, petal_length: 1.4, petal_width: 0.2 } },
      { id: 2, label: 'alcea setosa', x: 1.4, y: 1.0, source: 'Original dataset', inTraining: true, image: 'static/images/alcea_setosa.jpg',
        features: { sepal_length: 4.9, sepal_width: 3.0, petal_length: 1.4, petal_width: 0.2 } },
      { id: 3, label: 'echeveria setosa', x: 1.0, y: 0.9, source: 'Original dataset', inTraining: true, image: 'static/images/echeveria_setosa.jpg',
        features: { sepal_length: 4.7, sepal_width: 3.2, petal_length: 1.3, petal_width: 0.2 } },
      { id: 4, label: 'oxalis versicolor', x: 3.1, y: 2.2, source: 'Original dataset', inTraining: true, image: 'static/images/oxalis_versicolor.jpg',
        features: { sepal_length: 6.2, sepal_width: 2.8, petal_length: 4.8, petal_width: 1.8 } },
      { id: 5, label: 'sumpfiris iris versicolor', x: 2.9, y: 2.0, source: 'Original dataset', inTraining: true, image: 'static/images/sumpfiris_iris_versicolor.jpg',
        features: { sepal_length: 6.0, sepal_width: 2.7, petal_length: 4.5, petal_width: 1.5 } },
      { id: 6, label: 'clematis versicolor', x: 3.3, y: 2.4, source: 'Original dataset', inTraining: true, image: 'static/images/clematis_versicolor.jpg',
        features: { sepal_length: 5.9, sepal_width: 2.9, petal_length: 4.2, petal_width: 1.5 } },
      { id: 7, label: 'iris virginica', x: 4.0, y: 3.1, source: 'Original dataset', inTraining: true, image: 'static/images/iris_virginica.jpg',
        features: { sepal_length: 7.2, sepal_width: 3.0, petal_length: 6.0, petal_width: 2.0 } },
      { id: 8, label: 'mertensia virginica', x: 4.3, y: 3.4, source: 'Original dataset', inTraining: true, image: 'static/images/mertensia_virginica.jpg',
        features: { sepal_length: 6.5, sepal_width: 3.0, petal_length: 5.5, petal_width: 2.1 } },
      { id: 9, label: 'itea virginica', x: 3.8, y: 2.9, source: 'Original dataset', inTraining: true, image: 'static/images/itea_virginica.jpg',
        features: { sepal_length: 6.7, sepal_width: 3.1, petal_length: 5.6, petal_width: 2.4 } }
    ];

    function colorForLabel(label) {
      const l = label.toLowerCase();
      if (l.includes('setosa')) return 'rgba(56,189,248,0.9)';
      if (l.includes('versicolor')) return 'rgba(34,197,94,0.9)';
      if (l.includes('virginica')) return 'rgba(244,114,182,0.9)';
      return 'rgba(148,163,184,0.9)';
    }

    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, (c) =>
      ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c])
    );
  }


    let minkowskiP = 2.0;
    function distance2D(a, b, metric) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      if (metric === 'manhattan') return Math.abs(dx) + Math.abs(dy);
      if (metric === 'minkowski') {
        const p = minkowskiP;
        return Math.pow(Math.pow(Math.abs(dx), p) + Math.pow(Math.abs(dy), p), 1 / p);
      }
      return Math.hypot(dx, dy);
    }

    /* ============================== VIEW TABS ============================== */

    const pageNav = document.getElementById('page-nav');
    function setActiveNav(id) {
      if (!pageNav) return;
      pageNav.querySelectorAll('.view-tab').forEach((btn) => {
        btn.classList.toggle('active', btn.dataset.scroll === id);
      });
    }
    function scrollToSection(id) {
       const el = document.getElementById(id);
       if (!el) return;
       setActiveNav(id);
       el.scrollIntoView({ behavior: 'smooth', block: 'start' });
       setTimeout(() => {
        resizeScatterSoon();
      }, 250);
    }

    if (pageNav) {
      pageNav.querySelectorAll('.view-tab[data-scroll]').forEach((btn) => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          scrollToSection(btn.dataset.scroll);
        });
      });
    }



    /* ============================ PARAMETER CONTROLS =========================== */
    const kSlider = document.getElementById('k-slider');
    const kValueBadge = document.getElementById('k-value');
    const metricSelect = document.getElementById('metric-select');
    const metricDescription = document.getElementById('metric-description');
    const summaryK = document.getElementById('summary-k');
    const summaryMetric = document.getElementById('summary-metric');
    const summaryK2 = document.getElementById('summary-k-2');
    const summaryMetric2 = document.getElementById('summary-metric-2');

    function updateSettingsSummary() {
      const kText = `k = ${kSlider.value}`;
      const metricName = metricSelect.options[metricSelect.selectedIndex].text.split(' ')[0];
      summaryK.textContent = kText;
      summaryMetric.textContent = `Metric: ${metricName}`;
      summaryK2.textContent = kText;
      summaryMetric2.textContent = `Metric: ${metricName}`;
    }

    kSlider.addEventListener('input', () => {
      kValueBadge.textContent = kSlider.value;
      updateSettingsSummary();
      updateScatterHighlight();
      updateDistanceTable();
      syncComparisonIfOpen();
    });

    metricSelect.addEventListener('change', () => {
      const v = metricSelect.value;
      metricDescription.textContent =
        v === 'euclidean'
          ? 'Euclidean distance measures straight-line distance, like a ruler.'
          : v === 'manhattan'
          ? 'Manhattan distance adds absolute differences along each feature.'
          : 'Minkowski generalises both Euclidean (p=2) and Manhattan (p=1).';
      updateSettingsSummary();
      syncDistanceTabs(v);
      updateScatterHighlight();
      updateDistanceTable();
      syncComparisonIfOpen();
    });

    /* ============================= EXPLANATION TABS ============================= */
    const distanceTabs = document.querySelectorAll('.distance-tab');
    const distancePanels = document.querySelectorAll('.distance-panel');
    function syncDistanceTabs(metric) {
      distanceTabs.forEach((t) =>
        t.classList.toggle('active', t.dataset.metric === metric)
      );
      distancePanels.forEach((p) =>
        p.classList.toggle('active', p.dataset.metric-panel === metric)
      );
    }
    distanceTabs.forEach((tab) => {
      tab.addEventListener('click', () => {
        metricSelect.value = tab.dataset.metric;
        metricSelect.dispatchEvent(new Event('change'));
      });
    });

    /* ================ MINKOWSKI SLIDER ================= */
    const pSlider = document.getElementById('p-slider');
    const pValueLabel = document.getElementById('p-value');
    pSlider.addEventListener('input', () => {
      minkowskiP = parseFloat(pSlider.value);
      pValueLabel.textContent = `p = ${minkowskiP.toFixed(1)}`;
      updateScatterHighlight();
      updateDistanceTable();
      syncComparisonIfOpen();
    });

    const compareOpenBtn = document.getElementById('btn-open-compare');
    const compareModal = document.getElementById('comparison-modal');
    const compareBackdrop = document.getElementById('comparison-backdrop');
    const compareCloseBtn = document.getElementById('comparison-close');
    const compareMainBadge = document.getElementById('compare-main-badge');
    const compareMainPBadge = document.getElementById('compare-main-p-badge');
    const compareAltBadge = document.getElementById('compare-alt-badge');
    const compareAltPBadge = document.getElementById('compare-alt-p-badge');
    const compareK = document.getElementById('compare-k');
    const compareKValue = document.getElementById('compare-k-value');
    const compareMetric = document.getElementById('compare-metric');
    const compareMetricDesc = document.getElementById('compare-metric-description');
    const comparePWrap = document.getElementById('compare-p-wrap');
    const comparePSlider = document.getElementById('compare-p-slider');
    const comparePValue = document.getElementById('compare-p-value');
    const compareMainResult = document.getElementById('compare-main-result');
    const compareAltResult = document.getElementById('compare-alt-result');
    const compareSwapBtn = document.getElementById('comparison-swap');
    const compareCopyCurrentBtn = document.getElementById('comparison-copy-current');
    let lastCommittedMainSettings = null;

function getMainSettings() {
  return {
    k: Number(kSlider.value),
    metric: metricSelect.value,
    p: Number(minkowskiP) 
  };
}

function getCompareSettings() {
  return {
    k: Number(compareK.value),
    metric: compareMetric.value,
    p: Number(comparePSlider.value)
  };
}

function updateCompareMetricHelp() {
  const v = compareMetric.value;
  compareMetricDesc.textContent =
    v === 'euclidean'
      ? 'Euclidean distance measures straight-line distance, like a ruler.'
      : v === 'manhattan'
      ? 'Manhattan distance adds absolute differences along each feature.'
      : 'Minkowski generalises both Euclidean (p=2) and Manhattan (p=1).';
}

function updateComparePVisibility() {
  const show = compareMetric.value === 'minkowski';
  comparePWrap.style.display = show ? 'block' : 'none';
  compareAltPBadge.style.display = show ? 'inline-flex' : 'none';
}

function updateMainPVisibilityBadge() {
  const show = metricSelect.value === 'minkowski';
  compareMainPBadge.style.display = show ? 'inline-flex' : 'none';
}

function setCompareSettings(s) {
  compareK.value = String(s.k);
  compareKValue.textContent = String(s.k);

  compareMetric.value = s.metric;
  updateCompareMetricHelp();

  comparePSlider.value = String(s.p ?? 2);
  comparePValue.textContent = `p = ${Number(comparePSlider.value).toFixed(1)}`;

  updateComparePVisibility();
  updateComparisonBadges();
}

function isComparisonOpen() {
  return compareModal && compareModal.classList.contains('open');
}

let compareResizeObserver = null;

function resizeComparisonPlots() {
  if (!isComparisonOpen()) return;

  const a = document.getElementById('compare-plot-main');
  const b = document.getElementById('compare-plot-alt');

  if (window.Plotly?.Plots?.resize) {
    if (a) Plotly.Plots.resize(a);
    if (b) Plotly.Plots.resize(b);
  }
}

window.addEventListener('resize', resizeComparisonPlots);

function openComparisonView({ seedCompareSettings } = {}) {
  if (!compareModal) return;

  setCompareSettings(seedCompareSettings || getMainSettings());

  compareModal.classList.add('open');
  compareModal.setAttribute('aria-hidden', 'false');
  document.body.classList.add('modal-open');

  if (!compareResizeObserver && window.ResizeObserver) {
    const dialog = compareModal.querySelector('.comparison-dialog');
    if (dialog) {
      compareResizeObserver = new ResizeObserver(() => resizeComparisonPlots());
      compareResizeObserver.observe(dialog);
    }
  }

  requestAnimationFrame(() => {
    renderComparisonPlots();
    setTimeout(() => {
      renderComparisonPlots();
      resizeComparisonPlots();
    }, 50);
  });
}

function closeComparisonView() {
  if (!compareModal) return;

  compareModal.classList.remove('open');
  compareModal.setAttribute('aria-hidden', 'true');
  document.body.classList.remove('modal-open');

  if (compareResizeObserver) {
    compareResizeObserver.disconnect();
    compareResizeObserver = null;
  }
}



function distance2DWithP(a, b, metric, p) {
  const dx = a.x - b.x;
  const dy = a.y - b.y;

  if (metric === 'manhattan') return Math.abs(dx) + Math.abs(dy);

  if (metric === 'minkowski') {
    const pp = Math.max(1e-6, Number(p) || 2);
    return Math.pow(Math.pow(Math.abs(dx), pp) + Math.pow(Math.abs(dy), pp), 1 / pp);
  }

  return Math.hypot(dx, dy);
}

function getRefPoint() {
  return queryPoint || (selectedRowId ? datasetPoints.find((p) => p.id === selectedRowId) : null);
}

function nearestIdsForSettings(ref, settings) {
  if (!ref) return [];
  const k = Math.max(1, Math.min(settings.k, datasetPoints.length));

  return datasetPoints
    .map((p) => ({ id: p.id, d: distance2DWithP(p, ref, settings.metric, settings.p) }))
    .sort((a, b) => a.d - b.d)
    .slice(0, k)
    .map((o) => o.id);
}

function voteForSettings(ref, settings) {
  if (!ref) return null;

  const ids = nearestIdsForSettings(ref, settings);
  const counts = {};

  ids.forEach((id) => {
    const p = datasetPoints.find((d) => d.id === id);
    if (!p) return;
    const cls = baseClassJs(p.label);
    counts[cls] = (counts[cls] || 0) + 1;
  });

  const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);
  if (!sorted.length) return null;

  const [winner, count] = sorted[0];
  const confidence = Math.round((count / Math.max(1, settings.k)) * 100);
  return { winner, confidence, counts };
}

function renderVote(el, v) {
  if (!el) return;

  if (!v) {
    el.innerHTML =
      '<p class="compare-empty">Upload a flower (or select a point) to compare neighbours.</p>';
    return;
  }

  const parts = Object.entries(v.counts)
    .sort((a, b) => b[1] - a[1])
    .map(([cls, n]) => `${cls}: <strong>${n}</strong>`)
    .join(' ¬∑ ');

  el.innerHTML = `
    <div class="compare-vote">
      <div><strong>Prediction:</strong> <span class="compare-pred">${v.winner}</span></div>
      <div class="compare-conf"><strong>Confidence:</strong> ${v.confidence}%</div>
      <div class="compare-counts">${parts}</div>
    </div>
  `;
}

function buildScatterFor(containerId, ref, settings) {
  const el = typeof containerId === 'string'
    ? document.getElementById(containerId)
    : containerId;

  if (!el) return;

  if (!el.style.height) el.style.height = '360px';
  el.innerHTML = '';

  const nearest = ref ? nearestIdsForSettings(ref, settings) : [];

  const x = datasetPoints.map(p => p.x);
  const y = datasetPoints.map(p => p.y);
  const ids = datasetPoints.map(p => p.id);
  const labels = datasetPoints.map(p => p.label);

  const colors = [];
  const sizes = [];
  const lineColors = [];
  const lineWidths = [];
  const symbols = [];

  datasetPoints.forEach((p, i) => {
    colors[i] = colorForLabel(p.label);
    sizes[i] = 10;
    lineColors[i] = 'rgba(15,23,42,0.95)';
    lineWidths[i] = 1;
    symbols[i] = 'circle';

    if (nearest.includes(p.id)) {
      sizes[i] = 18;
      lineColors[i] = 'rgba(250,204,21,1)';
      lineWidths[i] = 6;
    }

    if (selectedRowId != null && p.id === selectedRowId) {
      symbols[i] = 'diamond';
      sizes[i] = Math.max(sizes[i], 22);
      lineColors[i] = 'rgba(56,189,248,1)';
      lineWidths[i] = Math.max(lineWidths[i], 6);
    }
  });

  const xAll = queryPoint ? [...x, queryPoint.x] : x;
  const yAll = queryPoint ? [...y, queryPoint.y] : y;

  const minX = Math.min(...xAll), maxX = Math.max(...xAll);
  const minY = Math.min(...yAll), maxY = Math.max(...yAll);
  const padX = (maxX - minX) * 0.15 || 0.5;
  const padY = (maxY - minY) * 0.15 || 0.5;

  const tracePoints = {
    x, y,
    mode: 'markers',
    type: 'scatter',
    marker: {
      size: sizes,
      color: colors,
      symbol: symbols,
      line: { width: lineWidths, color: lineColors }
    },
    text: labels.map((l, i) => `Id: ${ids[i]}<br>Class: ${escapeHtml(l)}`),
    hovertemplate: '%{text}<br>x: %{x}<br>y: %{y}<extra></extra>'
  };

  const traceQuery = {
    x: queryPoint ? [queryPoint.x] : [],
    y: queryPoint ? [queryPoint.y] : [],
    mode: 'markers',
    type: 'scatter',
    marker: {
      size: queryPoint ? 18 : 0,
      symbol: 'star',
      color: 'rgba(56,189,248,1)'
    },
    text: [chatUploadEntry ? 'Chat upload' : 'Uploaded flower'],
    hovertemplate: '%{text}<extra></extra>'
  };

  Plotly.newPlot(
    el,
    [tracePoints, traceQuery],
    {
      height: 360,
      margin: { t: 8, r: 8, b: 28, l: 28 },
      xaxis: { range: [minX - padX, maxX + padX], zeroline: false },
      yaxis: { range: [minY - padY, maxY + padY], zeroline: false },
      hovermode: 'closest',
      showlegend: false,
      paper_bgcolor: 'rgba(0,0,0,0)',
      plot_bgcolor: 'rgba(0,0,0,0)'
    },
    { responsive: true, displayModeBar: false }
  );
}








function updateComparisonBadges() {
  const main = getMainSettings();
  const alt = getCompareSettings();

  const metricNameMain = metricSelect.options[metricSelect.selectedIndex].text.split(' ')[0];
  const metricNameAlt = compareMetric.options[compareMetric.selectedIndex].text.split(' ')[0];

  compareMainBadge.textContent = `k = ${main.k} ¬∑ ${metricNameMain}`;
  compareAltBadge.textContent = `k = ${alt.k} ¬∑ ${metricNameAlt}`;

  updateMainPVisibilityBadge();

  if (main.metric === 'minkowski') {
    compareMainPBadge.textContent = `p = ${Number(main.p).toFixed(1)}`;
  }
  if (alt.metric === 'minkowski') {
    compareAltPBadge.textContent = `p = ${Number(alt.p).toFixed(1)}`;
  }
}

function renderComparisonPlots() {
  if (!isComparisonOpen()) return;

  const ref = getRefPoint();
  const main = getMainSettings();
  const alt = getCompareSettings();

  updateComparisonBadges();

  buildScatterFor('compare-plot-main', ref, main);
  buildScatterFor('compare-plot-alt', ref, alt);

  renderVote(compareMainResult, voteForSettings(ref, main));
  renderVote(compareAltResult, voteForSettings(ref, alt));
}

function handleMainSettingsCommitted() {
  const ref = getRefPoint();

  if (!ref) {
    lastCommittedMainSettings = getMainSettings();
    return;
  }

  const now = getMainSettings();
  const prev = lastCommittedMainSettings || now;

  if (prev.k === now.k && prev.metric === now.metric && Number(prev.p) === Number(now.p)) return;

  openComparisonView({ seedCompareSettings: prev });
  lastCommittedMainSettings = now;
}

if (compareOpenBtn) compareOpenBtn.addEventListener('click', () => openComparisonView());
if (compareCloseBtn) compareCloseBtn.addEventListener('click', closeComparisonView);
if (compareBackdrop) compareBackdrop.addEventListener('click', closeComparisonView);
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && isComparisonOpen()) closeComparisonView();
});

if (compareK) {
  compareK.addEventListener('input', () => {
    compareKValue.textContent = compareK.value;
    updateComparisonBadges();
    renderComparisonPlots();
  });
}

if (compareMetric) {
  compareMetric.addEventListener('change', () => {
    updateCompareMetricHelp();
    updateComparePVisibility();
    updateComparisonBadges();
    renderComparisonPlots();
  });
}

if (comparePSlider) {
  comparePSlider.addEventListener('input', () => {
    comparePValue.textContent = `p = ${Number(comparePSlider.value).toFixed(1)}`;
    updateComparisonBadges();
    renderComparisonPlots();
  });
}

if (compareSwapBtn) {
  compareSwapBtn.addEventListener('click', () => {
    const main = getMainSettings();
    const alt = getCompareSettings();

    setCompareSettings(main);

    kSlider.value = String(alt.k);
    kValueBadge.textContent = String(alt.k);
    metricSelect.value = alt.metric;
    pSlider.value = String(alt.p);

    metricSelect.dispatchEvent(new Event('change'));
    pSlider.dispatchEvent(new Event('input'));
    kSlider.dispatchEvent(new Event('input'));

    lastCommittedMainSettings = getMainSettings();
    renderComparisonPlots();
  });
}

if (compareCopyCurrentBtn) {
  compareCopyCurrentBtn.addEventListener('click', () => {
    setCompareSettings(getMainSettings());
    renderComparisonPlots();
  });
}

kSlider.addEventListener('change', handleMainSettingsCommitted);
pSlider.addEventListener('change', handleMainSettingsCommitted);
metricSelect.addEventListener('change', handleMainSettingsCommitted);

function syncComparisonIfOpen() {
  if (isComparisonOpen()) renderComparisonPlots();
}





    /* ================================ CHAT ==================================== */
    const chatWindow = document.getElementById('chat-window');
    const similarityText = document.getElementById('similarityText');

    function addChatMessage(content, sender = 'user', isHTML = false) {
      const wrap = document.createElement('div');
      wrap.classList.add('chat-message', sender);
      const bubble = document.createElement('div');
      bubble.classList.add('chat-bubble');
      if (isHTML) bubble.innerHTML = content;
      else bubble.textContent = content;
      wrap.appendChild(bubble);
      chatWindow.appendChild(wrap);
      chatWindow.scrollTop = chatWindow.scrollHeight;
    }

    async function sendToBackend(message) {
      try {
        const res = await fetch('/api/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message })
        });
        const data = await res.json();
        if (data.reply) addChatMessage(data.reply, 'bot');
        else addChatMessage('Server returned no reply.', 'bot');
      } catch {
        addChatMessage('Error contacting backend.', 'bot');
      }
    }

    async function sendImageToBackend(file) {
      const formData = new FormData();
      formData.append('file', file);
      formData.append('k', kSlider.value);
      formData.append('metric', metricSelect.value);
      formData.append('p', pSlider.value);

      try {
        const res = await fetch('/api/predict', { method: 'POST', body: formData });
        const data = await res.json();

        if (data.prediction && data.class) {
          const emoji =
            data.class === 'Setosa' ? 'üå∏' :
            data.class === 'Versicolor' ? 'üå∏' :
            data.class === 'Virginica' ? 'üåº' : 'üåª';

          const summaryHtml = data.summary
            ? data.summary.split('\n').map(line => escapeHtml(line)).join('<br>')
            : '';

          addChatMessage(
            `
            <div>
              <div>${escapeHtml(data.prediction)}</div>
              <br>
              <div><strong>${emoji} ${escapeHtml(data.class)}</strong></div>
              <div>${summaryHtml}</div>
            </div>
            `,
            'bot',
            true
          );
        }

        if (typeof data.similarity === 'number') {
          similarityText.textContent = `Similarity to closest flower: ${data.similarity}%`;
        }

        return data;
      } catch {
        addChatMessage('Error sending image to backend.', 'bot');
        return null;
      }
    }

    document.getElementById('chat-send').addEventListener('click', async () => {
      const msg = document.getElementById('chat-input').value.trim();
      if (!msg && !pendingImageFile) return;

      // Add user text message (if any)
      if (msg) {
        addChatMessage(msg, 'user');
        document.getElementById('chat-input').value = '';
      }

      // If user uploaded an image ‚Üí NOW send it, and do NOT also call /api/chat for this turn
      if (pendingImageFile) {
        const reader = new FileReader();
        reader.onload = (ev) => {
          addChatMessage(
            `<div class="image-message">
               <img src="${ev.target.result}" class="chat-image-preview"/>
               <div class="image-caption">Uploaded image</div>
             </div>`,
            'user',
            true
          );
        };
        reader.readAsDataURL(pendingImageFile);

        const predictionData = await sendImageToBackend(pendingImageFile);

        document.getElementById('pending-preview').innerHTML = '';
        pendingImageFile = null;
        fileInput.value = '';

        if (predictionData?.coords) {
          setQueryPointFromBackend(
            predictionData.coords,
            {
              className: predictionData.class,
              image: pendingImageDataUrl
            }
          );
        }

        if (predictionData?.original_image) {
          document.getElementById('explainOriginalImage').src =
            predictionData.original_image;
        }
        if (predictionData?.heatmap_image) {
          document.getElementById('explainHeatmapImage').src =
            predictionData.heatmap_image;
        }

        // Stop here ‚Äì no /api/chat call for this message
        return;
      }

      // No image ‚Üí normal chat
      if (msg) {
        sendToBackend(msg);
      }
    });

    document.getElementById('chat-input').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        document.getElementById('chat-send').click();
      }
    });

    /* ================= IMAGE UPLOAD / QUERY POINT ===================== */
    const CHAT_UPLOAD_ID = 0; 
    let queryPoint = null;     
    let pendingImageFile = null;
    let pendingImageDataUrl = null; 
    let chatUploadEntry = null;     

    const uploadBtn = document.getElementById('chat-upload-btn');
    const fileInput = document.getElementById('file-input');

    uploadBtn.addEventListener('click', () => fileInput.click());

    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;

      pendingImageFile = file;

      const reader = new FileReader();
      reader.onload = (ev) => {
        pendingImageDataUrl = ev.target.result;
        document.getElementById('pending-preview').innerHTML = `
          <img src="${ev.target.result}"
               style="width:80px;height:80px;object-fit:cover;border-radius:10px;border:2px solid #4ade80;">
          <p style="margin-top:5px; font-size:0.85rem; color:#4ade80;">
            Image ready. Type a question and press Send.
          </p>
        `;
      };
      reader.readAsDataURL(file);
    });
    
    function setQueryPointFromBackend(coords, meta = {}) {
      if (!coords) return;
      queryPoint = { x: coords[0], y: coords[1] };
      chatUploadEntry = {
        id: CHAT_UPLOAD_ID,
        label: meta.className || 'Chat upload',
        x: queryPoint.x,
        y: queryPoint.y,
        source: 'Chat upload',
        inTraining: false,
        image: meta.image || '',
        features: { sepal_length: 0, sepal_width: 0, petal_length: 0, petal_width: 0 }
      };
      renderDatasetTable();
      initScatterPlot();           
      selectDatasetRow(CHAT_UPLOAD_ID);
      showPointDetails(chatUploadEntry);
    }

    /* =========================== DATASET TABLE ================================== */
    const datasetTableBody = document.querySelector('#dataset-table tbody');
    const classFilter = document.getElementById('class-filter');
    const removeBtn = document.getElementById('btn-remove-image');
    const addBtn = document.getElementById('btn-add-image');
    const datasetFileInput = document.getElementById('dataset-file-input');
    const pointDetailsDiv = document.getElementById('point-details');

    let selectedRowId = null;

    function renderDatasetTable() {
      const filter = classFilter.value;
      datasetTableBody.innerHTML = '';
      const allPoints = chatUploadEntry ? [chatUploadEntry, ...datasetPoints] : datasetPoints;
      allPoints
      .filter((p) => filter === 'all' || p.label.toLowerCase().includes(filter))
      .forEach((p) => {
          const tr = document.createElement('tr');
          tr.dataset.id = p.id;
          tr.innerHTML = `
            <td>${p.image ? `<img src="${p.image}" class="thumb-img"/>` : ''}</td>
            <td>${p.id}</td>
            <td>${escapeHtml(p.label)}</td>
            <td>${escapeHtml(p.source)}</td>
            <td>${p.inTraining ? 'Yes' : 'No'}</td>
          `;
          tr.addEventListener('click', () => {
            selectDatasetRow(p.id);
            showPointDetails(p);
          });
          datasetTableBody.appendChild(tr);
        });
    }

    classFilter.addEventListener('change', renderDatasetTable);

    addBtn.addEventListener('click', () => datasetFileInput.click());
    datasetFileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        const newId = Math.max(...datasetPoints.map((p) => p.id)) + 1;
        const label = prompt('Enter a class for this flower:', 'new_flower') || 'new_flower';
        const avgX = datasetPoints.reduce((s, p) => s + p.x, 0) / datasetPoints.length;
        const avgY = datasetPoints.reduce((s, p) => s + p.y, 0) / datasetPoints.length;
        const jitterX = (Math.random() - 0.5) * 0.7;
        const jitterY = (Math.random() - 0.5) * 0.7;
        datasetPoints.push({
          id: newId,
          label,
          x: avgX + jitterX,
          y: avgY + jitterY,
          source: 'User upload',
          inTraining: true,
          image: ev.target.result,
          features: { sepal_length: 0, sepal_width: 0, petal_length: 0, petal_width: 0 }
        });
        renderDatasetTable();
        initScatterPlot();
        selectDatasetRow(newId);
        showPointDetails(datasetPoints[datasetPoints.length - 1]);
      };
      reader.readAsDataURL(file);
      e.target.value = '';
    });

    removeBtn.addEventListener('click', () => {
      if (selectedRowId == null) return;
      if (selectedRowId === CHAT_UPLOAD_ID) {
        chatUploadEntry = null;
        queryPoint = null;
        selectedRowId = null;
        removeBtn.disabled = true;
        removeBtn.textContent = 'Remove selected image';
        pointDetailsDiv.innerHTML = '<p>No point selected yet. Click a dot or row.</p>';
        renderDatasetTable();
        initScatterPlot();
        return;
      }
      
      const idx = datasetPoints.findIndex((p) => p.id === selectedRowId);
      if (idx < 0) return;
      datasetPoints.splice(idx, 1);
      selectedRowId = null;
      removeBtn.disabled = true;
      renderDatasetTable();
      initScatterPlot();
      pointDetailsDiv.innerHTML = '<p>Point removed.</p>';
    });

    function selectDatasetRow(id) {
      selectedRowId = id;
      const selectedPoint =
      id === CHAT_UPLOAD_ID ? chatUploadEntry : datasetPoints.find((p) => p.id === id);
      const isTraining = !!selectedPoint && (selectedPoint.inTraining !== false);
      const canRemove = !!selectedPoint && (isTraining || id === CHAT_UPLOAD_ID);
      removeBtn.disabled = !canRemove;
      if (id === CHAT_UPLOAD_ID) {
        removeBtn.textContent = 'Remove chat upload';
      } else {
        removeBtn.textContent = 'Remove selected image';
      }
      document.querySelectorAll('#dataset-table tbody tr').forEach((tr) => {
        tr.classList.toggle('active', Number(tr.dataset.id) === id);
      });
      updateScatterHighlight();
      if (id === CHAT_UPLOAD_ID) {
        focusQueryInScatter();
      } else {
        const idx = datasetPoints.findIndex((p) => p.id === id);
        if (idx >= 0) focusPointInScatter(idx);
      }
    }


  function focusPointInScatter(pointIndex) {
  const plotEl = document.getElementById('dataset-scatter');
  if (!plotEl || !scatterInitialized) return;
  if (Plotly?.Fx?.hover) {
    Plotly.Fx.hover(plotEl, [{ curveNumber: 0, pointNumber: pointIndex }]);
  }
  const p = datasetPoints[pointIndex];
  const xr = plotEl.layout?.xaxis?.range;
  const yr = plotEl.layout?.yaxis?.range;
  if (!xr || !yr) return;

  const padX = (xr[1] - xr[0]) * 0.08 || 0.5;
  const padY = (yr[1] - yr[0]) * 0.08 || 0.5;

  Plotly.relayout(plotEl, {
    'xaxis.range': [Math.min(xr[0], p.x - padX), Math.max(xr[1], p.x + padX)],
    'yaxis.range': [Math.min(yr[0], p.y - padY), Math.max(yr[1], p.y + padY)],
  });
}

function focusQueryInScatter() {
  const plotEl = document.getElementById('dataset-scatter');
  if (!plotEl || !scatterInitialized || !queryPoint) return;
  if (Plotly?.Fx?.hover) {
    Plotly.Fx.hover(plotEl, [{ curveNumber: 1, pointNumber: 0 }]);
  }
}

    function showPointDetails(p) {
      pointDetailsDiv.innerHTML = `
        ${p.image ? `<img src="${p.image}" class="point-details-image"/>` : ''}
        <p><strong>Id:</strong> ${p.id}</p>
        <p><strong>Class:</strong> ${escapeHtml(p.label)}</p>
        <p><strong>Source:</strong> ${escapeHtml(p.source)}</p>
        <p><strong>Used in training:</strong> ${p.inTraining ? 'Yes' : 'No'}</p>
      `;
    }


    /* ============================= SCATTER PLOT ============================= */
    let scatterInitialized = false;
    function resizeScatterSoon() {
      requestAnimationFrame(() => {
        const el = document.getElementById('dataset-scatter');
        if (!el) return;
        if (window.Plotly && Plotly.Plots && typeof Plotly.Plots.resize === 'function') {
          Plotly.Plots.resize(el);
        }
      });
    }

    function initScatterPlot() {
      const el = document.getElementById('dataset-scatter');
      if (!el) return;
      if (!el.style.height) el.style.height = '420px';
      scatterInitialized = true;
      updateScatterHighlight();
      resizeScatterSoon();
    }

    
    function updateQueryTrace() {
      if (!scatterInitialized) return;
      updateScatterHighlight();
    }
    function updateScatterHighlight() {
      if (!scatterInitialized) return;
      const el = document.getElementById('dataset-scatter');
      if (!el) return;
      const settings = getMainSettings();
      const ref = getRefPoint();
      const nearest = ref ? nearestIdsForSettings(ref, settings) : [];

      const x = datasetPoints.map((p) => p.x);
      const y = datasetPoints.map((p) => p.y);
      const ids = datasetPoints.map((p) => p.id);
      const labels = datasetPoints.map((p) => p.label);

      const colors = [];
      const sizes = [];
      const lineColors = [];
      const lineWidths = [];
      const symbols = [];

      datasetPoints.forEach((p, i) => {
        colors[i] = colorForLabel(p.label);
        sizes[i] = 10;
        lineColors[i] = 'rgba(15,23,42,0.95)';
        lineWidths[i] = 1;
        symbols[i] = 'circle';

        if (nearest.includes(p.id)) {
          sizes[i] = 18;
          lineColors[i] = 'rgba(250,204,21,1)';
          lineWidths[i] = 6;
        }

        if (selectedRowId != null && p.id === selectedRowId) {
          symbols[i] = 'diamond';
          sizes[i] = Math.max(sizes[i], 22);
          lineColors[i] = 'rgba(56,189,248,1)';
          lineWidths[i] = Math.max(lineWidths[i], 6);
        }
      });

      const xAll = queryPoint ? [...x, queryPoint.x] : x;
      const yAll = queryPoint ? [...y, queryPoint.y] : y;

      const minX = Math.min(...xAll);
      const maxX = Math.max(...xAll);
      const minY = Math.min(...yAll);
      const maxY = Math.max(...yAll);
      const padX = (maxX - minX) * 0.15 || 0.5;
      const padY = (maxY - minY) * 0.15 || 0.5;

      const tracePoints = {
        x,
        y,
        mode: 'markers',
        type: 'scatter',
        marker: {
          size: sizes,
          color: colors,
          symbol: symbols,
          line: { width: lineWidths, color: lineColors }
        },
        text: labels.map((l, i) => `Id: ${ids[i]}<br>Class: ${escapeHtml(l)}`),
        hovertemplate: '%{text}<br>x: %{x}<br>y: %{y}<extra></extra>'
      };

      const traceQuery = {
        x: queryPoint ? [queryPoint.x] : [],
        y: queryPoint ? [queryPoint.y] : [],
        mode: 'markers',
        type: 'scatter',
        marker: {
          size: queryPoint ? 20 : 0,
          symbol: 'star',
          color: 'rgba(56,189,248,1)'
        },
        text: [chatUploadEntry ? 'Chat upload' : 'Uploaded flower'],
        hovertemplate: '%{text}<extra></extra>'
      };


      const p = Plotly.react(
        el,
        [tracePoints, traceQuery],
         {
          height: 420,
          margin: { t: 8, r: 8, b: 28, l: 28 },
          xaxis: { range: [minX - padX, maxX + padX], zeroline: false },
          yaxis: { range: [minY - padY, maxY + padY], zeroline: false },
          hovermode: 'closest',
          showlegend: false,
          paper_bgcolor: 'rgba(0,0,0,0)',
          plot_bgcolor: 'rgba(0,0,0,0)'
        },
        { responsive: true, displayModeBar: false }
      );
      if (p && typeof p.then === 'function') {
        p.then(() => {
          if (el.removeAllListeners) el.removeAllListeners('plotly_click');
          if (el.on) {
            el.on('plotly_click', (data) => {
              const pt = data.points[0];
              if (pt.curveNumber === 0) {
                const idx = pt.pointIndex;
                const point = datasetPoints[idx];
                showPointDetails(point);
                selectDatasetRow(point.id);
                return;
              }
              if (pt.curveNumber === 1 && chatUploadEntry) {
                showPointDetails(chatUploadEntry);
                selectDatasetRow(CHAT_UPLOAD_ID);
              }
            });
          }
        });
      }
      updateDistanceTable();

    }



    /* ============================ DISTANCE TABLE ================================= */
    const distanceTableBody = document.querySelector('#distance-table tbody');
    const voteSummary = document.getElementById('vote-summary');

    function updateDistanceTable() {
      if (!distanceTableBody) return;
      const metric = metricSelect.value;
      const k = Number(kSlider.value);
      const ref =
        queryPoint ||
        (selectedRowId ? datasetPoints.find((p) => p.id === selectedRowId) : null);

      if (!ref) {
        distanceTableBody.innerHTML = `
          <tr><td colspan="8">Upload a flower or select a point to see distances.</td></tr>
        `;
        voteSummary.textContent = '';
        return;
      }

      const rows = datasetPoints
        .map((p) => {
          const dx = p.x - ref.x;
          const dy = p.y - ref.y;
          const d = distance2D(p, ref, metric);
          return { p, dx, dy, d };
        })
        .sort((a, b) => a.d - b.d);

      const maxNeighbours = Math.min(k, rows.length);

      distanceTableBody.innerHTML = rows
        .map((r, i) => {
          const isN = i < maxNeighbours;
          return `
            <tr class="${isN ? 'nearest-row' : ''}">
              <td>${i + 1}</td>
              <td>${r.p.id}</td>
              <td>${escapeHtml(r.p.label)}</td>
              <td>${r.p.x.toFixed(2)}</td>
              <td>${r.p.y.toFixed(2)}</td>
              <td>${r.dx.toFixed(2)}</td>
              <td>${r.dy.toFixed(2)}</td>
              <td>${r.d.toFixed(2)}</td>
            </tr>
          `;
        })
        .join('');

      const classCounts = {};
      rows.slice(0, maxNeighbours).forEach((r) => {
        const cls = baseClassJs(r.p.label);
        classCounts[cls] = (classCounts[cls] || 0) + 1;
      });

      const sorted = Object.entries(classCounts).sort((a, b) => b[1] - a[1]);
      if (sorted.length === 0) {
        voteSummary.textContent = '';
        return;
      }

      const [winner, count] = sorted[0];
      function classIcon(cls) {
        cls = cls.toLowerCase();
        if (cls.includes('setosa')) return 'üå∏';
        if (cls.includes('versicolor')) return 'üå∏';
        if (cls.includes('virginica')) return 'üåº';
        return 'üåª';
      }

      const confidence = Math.round((count / maxNeighbours) * 100);
      let confColor =
        confidence >= 70 ? '#22c55e' :
        confidence >= 40 ? '#eab308' :
                           '#ef4444';
      let confWidth = confidence + '%';
      let explanation =
        confidence >= 70 ? 'High confidence: most of the nearest neighbours agree.' :
        confidence >= 40 ? 'Medium confidence: the neighbours are mixed.' :
                           'Low confidence: the neighbours disagree.';

      voteSummary.innerHTML = `
        <div class="vote-card">
          <div class="vote-line">
            <strong>Confidence:</strong>
            <span style="color:${confColor}; font-weight:600;">${confidence}%</span>
          </div>
          <div class="confidence-bar">
            <div class="tooltip">${explanation}</div>
            <div class="confidence-fill" style="width:${confWidth};"></div>
          </div>
          <div style="margin-top: 12px; font-size: 1rem;">
            ${sorted.map(([cls, n]) => `${classIcon(cls)} ${cls}: <strong>${n}</strong>`).join(' ¬∑ ')}
          </div>
          <div style="margin-top: 12px; font-size: 1.05rem;">
            üåº <strong>Prediction:</strong>
            <span style="color:#38bdf8;">${winner}</span>
          </div>
        </div>
      `;
    }


    /* ===================== STEP-GUIDE ===================== */
    const howSteps = document.querySelectorAll('.how-step');
    const howTitle = document.getElementById('how-step-title');
    const howText = document.getElementById('how-step-text');

    const HOW = {
      1: {
        title: '1 ¬∑ Model memory',
        html:
        'FlowerLens starts with a small training dataset of labelled flower images. ' +
        'This is the model‚Äôs memory. You can explore it in the ' +
        '<a href="#view-dataset">Explore the training data</a>.',
        scrollTo: 'view-dataset',
        glow: 'view-dataset'
      },
      2: {
        title: '2 ¬∑ Your flower',
        html:
        'Upload a flower image in the chat. FlowerLens extracts features and places your flower in the same space as the training data. ' +
        '<a href="#view-assistant">Upload your flower</a>.',
        scrollTo: 'view-assistant',
        glow: 'view-assistant'
      },
      3: {
        title: '3 ¬∑ Feature space',
        html:
        'Each flower is represented as a point in the scatter plot. Similar flowers appear closer together. ' +
        '<a href="#feature-space">See the scatter plot</a>.',
        scrollTo: 'feature-space',
        glow: 'feature-space'
      },
      4: {
        title: '4 ¬∑ Measure distances',
        html:
        'The model computes distances from your flower to every training point using the chosen metric (Euclidean/Manhattan/Minkowski). ' +
        '<a href="#distance-explanation">See how distance is calculated</a>.',        scrollTo: 'distance-explanation',
        glow: 'distance-explanation'
      },
      5: {
         title: '5 ¬∑ Nearest neighbours',
          html:
          'The <strong>k</strong> closest points become the neighbours. In the scatter plot, they are highlighted with a gold ring. ' +
          '<a href="#feature-space">View the highlighted neighbours in the scatter plot</a>.',
          scrollTo: 'feature-space',
          glow: 'feature-space'
        },
        6: {
          title: '6 ¬∑ Neighbour vote',
          html:
          'Only the <strong>k</strong> neighbours vote. The class with the most votes becomes the prediction, and confidence depends on how dominant the winner is. ' +
          '<a href="#vote-summary">Jump to the vote summary</a>.',
          scrollTo: 'vote-summary',
          glow: 'vote-summary'
        },
        7: {
          title: '7 ¬∑ Explanation',
          html:
          'All panels work together: the chat explains the prediction in words, the dataset view shows the model‚Äôs memory, and the distances + vote show why the result happens. ' +
          '<a href="#heatmap-explainer-card">View the visual explanation</a>.',
          scrollTo: 'heatmap-explainer-card',
          glow: 'heatmap-explainer-card'
        }
      };


    function glowTarget(id) {
      const el = document.getElementById(id);
      if (!el) return;
      el.classList.add('step-target-glow');
      window.setTimeout(() => el.classList.remove('step-target-glow'), 1200);
    }
    function setHowStep(stepNum, { shouldScroll = false } = {}) {
      const cfg = HOW[stepNum];
      if (!cfg) return;
      howSteps.forEach((b) => b.classList.toggle('active', Number(b.dataset.step) === stepNum));
      if (howTitle) howTitle.textContent = cfg.title;
      if (howText) howText.innerHTML = cfg.html;
      if (shouldScroll && cfg.scrollTo && typeof scrollToSection === 'function') {
        scrollToSection(cfg.scrollTo);
        if (cfg.glow) setTimeout(() => glowTarget(cfg.glow), 250);
      }
    }
    howSteps.forEach((btn) => {
      btn.addEventListener('click', () =>
      setHowStep(Number(btn.dataset.step), { shouldScroll: false })
    );
  });

    document.getElementById('how-it-works')?.addEventListener('click', (e) => {
      const a = e.target.closest('a[href^="#"]');
      if (!a) return;
      const target = a.getAttribute('href')?.slice(1);
      if (target && typeof scrollToSection === 'function') {
        e.preventDefault();
        scrollToSection(target);
      }
    });


    renderDatasetTable();
    initScatterPlot();
    updateSettingsSummary();
  </script>
</body>
</html>